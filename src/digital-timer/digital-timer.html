<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<link rel="import" href="../digital-clock/digital-clock.html">
<link rel="import" href="../font-fill/font-fill.html">
<link rel="import" href="../shared-styles.html">

<script src="../../bower_components/lodash/lodash.js"></script>
<script src="../../bower_components/d3/d3.min.js"></script>

<dom-module id="digital-timer">
  <template>
    <style include="shared-styles">
      :host {
        display: block;
        overflow: hidden;
        @apply(--layout-vertical);
        @apply(--layout-center);
      }

      .show-prepare {
        display: none;
      }

      .show-work {
        display: none;
      }

      .show-rest {
        display: none;
      }

      .show-stopwatch {
        display: none;
      }

      [type="prepare"] .show-prepare {
        display: inherit;
      }

      [type="work"] .show-work {
        display: inherit;
      }

      [type="rest"] .show-rest {
        display: inherit;
      }

      [type="stopwatch"] .show-stopwatch {
        display: inherit;
      }

      [type="prepare"] .hide-prepare {
        visibility: hidden;
      }

      [type="work"] .hide-work {
        visibility: hidden;
      }

      [type="rest"] .hide-rest {
        visibility: hidden;
      }

      [type="stopwatch"] .hide-stopwatch {
        visibility: hidden;
      }
      
      #chartWrapper {
        position: relative;
      }

      #textWrapper h3 {
        font-size: 2em;
        line-height: 1em;
        padding: 0;
        margin: 0;
      }

      #textWrapper digital-clock {
        margin: 0;
        padding: 0;
      }
    </style>

    <div id="chartWrapper" class="flex layout vertical center-justified center" type$="[[period.type]]">
      <div id="textWrapper" class="pinned layout vertical center-justified center" style$="font-size: [[fontSize]]px;">
        <digital-clock class="hide-prepare" total-seconds="[[globalSeconds]]"></digital-clock>
        <font-fill id="fontFill" text="[[title]]" style="width: 6em; height: 2em; text-align: center;"></font-fill>
        <digital-clock total-seconds="[[periodSeconds]]"></digital-clock>
      </div>
      <div id="chart"></div>
    </div>

  </template>
  <script>
    Polymer({
       is: "digital-timer",

       behaviors: [Polymer.IronResizableBehavior],

       properties: {
         globalSeconds: Number,
         globalCycleSeconds: Number,
         globalCycle: Array,
         globalPercentage: {
           type: Number,
           computed: '_percentage(globalCycleSeconds, globalCycle, globalCycle.splices)'
         },
         periodCycle: Array,
         periodCycleSeconds: Number,
         periodSeconds: Number,
         periodPercentage: {
           type: Number,
           computed: '_percentage(periodCycleSeconds, periodCycle, periodCycle.splices)'
         },
         pie: {
           type: Object,
           value: function() {
             return d3.pie()
              .value(function(period) {
                return period.percentage;
              })
              .sort(null);
           }
         },
         accumulatedPie: {
           type: Object,
           value: function() {
             return d3.pie()
              .value(function(period) {
                return period.accumulatedPercentage;
              })
              .sort(null);
           }
         },
         height: Number,
         width: Number,
         fontSize: {
           type: Number,
           computed: '_fontSize(height, width)'
         },
         period: {
           type: Object,
           computed: '_period(globalSeconds, globalCycle, globalCycle.splices)'
         },
         title: {
           type: String,
           value: 'Press Play'
         },
         globalInnerCircle: Object,
         globalOuterCircle: Object,
         periodInnerCircle: Object,
         periodOuterCircle: Object,
         colorWheel: {
           type: Array,
           value: []
         }
       },
      
      // Listeners
      listeners: {
        'iron-resize': 'resize'
      },

      resize: function() {
        if (!this.debouncedResize) { // Debounced functions must be local, not shared
          this.debouncedResize = _.debounce(this.setDimensions.bind(this), 50);
        }
        this.debouncedResize();
      },


       // Observers
       observers: [
         '_title(period.name)',
         '_chart(width, height, globalCycle, periodCycle, globalCycle.splices, periodCycle.splices)',
         '_chartUpdate(globalPercentage, globalCycle, globalOuterCircle, globalCycle.splices)',
         '_chartUpdate(periodPercentage, periodCycle, periodOuterCircle, periodCycle.splices)'
       ],

       _fontSize: function(h, w) {
         var min = Math.min(h, w);
         return min * .08;
       },

       _period: function(globalSeconds, globalCycle) {
         var i = this.getPeriodIndex(globalSeconds, globalCycle);
         return globalCycle[i];
       },

       _percentage: function(cycleSeconds, cycle) {
         var totalSeconds = cycle.seconds || this.getCycleSeconds(cycle);
         return this.round(1 - cycleSeconds/totalSeconds);
       },

       _title: function(name) {
         return this.title = name;
       },

       _chart: function(width, height, globalCycle, periodCycle) {
         if (!width || !height) return;
         this.emptyChart();
         
         
         var minDimension = Math.max(0, Math.min(width, height)); // Prevent clipping in vert layouts 
         var w = minDimension;
         var h = minDimension;
         var arcWidth = minDimension * .08;
         var outerRadiusArc = w/2;
         var innerRadiusArc = outerRadiusArc - arcWidth;
         var shadowWidth = minDimension * .02;
         var outerRadiusArcShadow = innerRadiusArc + 1;
         var innerRadiusArcShadow = innerRadiusArc - shadowWidth;
         var color = d3.scaleOrdinal().range(this.colorWheel);
         var colorWheel = this.colorWheel;

         var svg = d3.select(this.$.chart)
          .append('svg')
          .attr('width', w)
          .attr('height', h)
          .attr('class', 'shadow')
          .append('g')
          .attr('transform', 'translate('+w/2+','+h/2+')');
         
         function outerCircleFill(d, i) {
           // Only filler arcs should be transparent
           if (!d.data.totalSeconds) return 'transparent';
           if (!d.data.color) return 'gray';
           return color(d.data.color);
         };

         function innerCircleFill(d, i) {
           var c = d3.hsl(color(d.data.color));
          return d3.hsl((c.h + 5), (c.s + .07), (c.l - .15));
         };
         
         
         var globalPeriods = this.getPeriods(this.globalPercentage, globalCycle);

         this.globalOuterCircle = this.createChart(globalPeriods, this.accumulatedPie, svg, outerRadiusArc, innerRadiusArc, outerCircleFill, 'globalOuterCircle'); 
         
         this.globalInnerCircle = this.createChart(globalPeriods, this.pie, svg, outerRadiusArcShadow, innerRadiusArcShadow, innerCircleFill, 'globalInnerCircle');

         var periodPeriods = this.getPeriods(this.periodPercentage, periodCycle);
         var periodInset = minDimension * .1;

         this.periodOuterCircle = this.createChart(periodPeriods, this.accumulatedPie, svg, outerRadiusArc - periodInset, innerRadiusArc - periodInset, outerCircleFill, 'periodOuterCircle'); 
         
         this.periodInnerCircle = this.createChart(periodPeriods, this.pie, svg, outerRadiusArcShadow - periodInset, innerRadiusArcShadow - periodInset, innerCircleFill, 'periodInnerCircle');
        
       },

       _chartUpdate: function(percentage, cycle, circle) {
         circle.update(this.getPeriods(percentage, cycle));
       },

       // Functions
       getPeriodIndex: function(seconds, periods) {
         var i = periods.length;
         while (i--) {
           seconds -= periods[i].totalSeconds
           if (seconds <= 0) break;
         }
         return i;
       },

       getPeriods: function(maxPercentage, cycle) {
         maxPercentage = maxPercentage || 0;

         var totalSeconds = cycle.seconds || this.getCycleSeconds(cycle);
         var accumulatedPercentage = 0;
         var periods = cycle.map(function(period) {
           if (!period) return;
           period.percentage = this.round(period.totalSeconds/totalSeconds);

           if (accumulatedPercentage + period.percentage <= maxPercentage) {
             period.accumulatedPercentage = period.percentage;
           } else {
             period.accumulatedPercentage = Math.max(0, this.round(maxPercentage - accumulatedPercentage));
           }

           accumulatedPercentage = accumulatedPercentage + period.percentage;
           
           return period;
         }.bind(this));

         var roundingError = this.round(1 - periods.reduce(function(i, p) {
           return i + p.percentage;
         }, 0));

         periods.push({
           name: 'Done',
           accumulatedPercentage: this.round(1 - periods.reduce(function(i, p) {
             return i + p.accumulatedPercentage;
           }, 0)) - roundingError
         });

         return periods;
       },

       getCycleSeconds: function(cycle) {
         return cycle.reduce(function(s, period) {
           return s + period.totalSeconds;
         }, 0);
       },

       createChart: function(periods, pie, svg, outerRadius, innerRadius, fillFunction, className) {
         var tau = 2 * Math.PI;
         var paths = getPaths();
         var arc = d3.arc()
            .innerRadius(innerRadius)
            .outerRadius(outerRadius);
         
         
         paths.transition()
          .duration(1000)
          .attrTween('d', function(d) {
            var interpolate = d3.interpolate({startAngle: 0, endAngle: 0}, d);
            return function(t) {
              return arc(interpolate(t));
            };
          });
          paths.data(pie(periods))
              .enter()
              .append('path')
              .attr('class', className)
              .attr('d', arc)
              .attr('fill', fillFunction);


         function getPaths() {
           return svg.selectAll('.' + className);
         };
         function update(periods) {
           if (periods.length > 2 && className != 'periodOuterCircle') {
             periods = periods.filter(function(p) {
               return p.type !== 'prepare';
             });
           }
           
           getPaths()
            .data(pie(periods))
            .attr('d', arc)
            .attr('fill', fillFunction);
              

            return {
              paths: paths,
              arc: arc,
              update: update
            };
         };
         return update(periods);
       },

       emptyChart: function() {
         var chart = this.$.chart;
         var children = chart.children;
         var i = children.length;
         while (i--) {
           chart.removeChild(children[i]);
         }
       },

       setDimensions: function() {
         this.width = this.offsetWidth;
         this.height = this.offsetHeight;
       },

       round: function(p) {
         return Math.round(p * 10000) / 10000;
       },

       refresh: function() {
        setTimeout(function() {
          this.fire('iron-resize');
          this.$.fontFill.fire('iron-resize');
          this.fire('refresh'); 
        }.bind(this), 100);  
       }

    });
  </script>
</dom-module>